# å¡ç‰‡æ“·å–èˆ‡æ¢¯å½¢æ ¡æ­£æµç¨‹
_Exported on 2025/11/27 at 18:45:05 [GMT+8] from Cursor (2.1.39)_

---

**User**

åƒè€ƒ@g:\æˆ‘çš„é›²ç«¯ç¡¬ç¢Ÿ\å ´å¤–ç”¨\ç¨‹å¼èªè¨€\Python\1_Python æ¨¡çµ„ç”¨æ³•\docaligner-docsaid æ–‡ä»¶é€è¦–æ ¡æ­£æ¨¡çµ„ å°ˆæ¡ˆï¼Œå°‡å¾Œç«¯æ”¶åˆ°çš„åœ–ç‰‡é€²è¡Œå¡ç‰‡çš„æ“·å–+æ¢¯å½¢æ ¡æ­£ï¼Œå¦‚æœæ“·å–æˆåŠŸï¼Œå°±å°‡æ ¡æ­£çµæœåœ–ç‰‡ç«‹å³å‚³å›å‰ç«¯é¡¯ç¤ºï¼Œä¸¦åœæ­¢å‚³é€ç•«é¢ï¼ŒåŒæ™‚è©¢å•ç”¨æˆ¶æ˜¯å¦é‡æ–°æ‹æ” /sequential-thinking 

--- Cursor Command: sequential-thinking.md ---
ä½¿ç”¨ sequential-thinking é€²è¡Œæ·±åº¦æ€è€ƒ
--- End Command ---

---

**Cursor**

è®“æˆ‘å…ˆé–±è®€ç›¸é—œæª”æ¡ˆä¾†äº†è§£å°ˆæ¡ˆçµæ§‹å’Œå¯¦ä½œæ–¹å¼ã€‚

è®“æˆ‘é€²ä¸€æ­¥äº†è§£ç•¶å‰å°ˆæ¡ˆçš„çµæ§‹å’Œä¾è³´é…ç½®ã€‚

ç¾åœ¨è®“æˆ‘æŸ¥çœ‹ç•¶å‰å°ˆæ¡ˆçš„ pyproject.toml å’Œ static/webcam.jsï¼š

ç¾åœ¨è®“æˆ‘ä½¿ç”¨ sequential-thinking ä¾†æ·±åº¦æ€è€ƒå¯¦ä½œæ–¹æ¡ˆï¼š

åŸºæ–¼æ·±åº¦æ€è€ƒçš„çµæœï¼Œæˆ‘ç¾åœ¨ç‚ºæ‚¨å‰µå»ºå¯¦ä½œè¨ˆç•«ï¼š

---

**User**

ä½ èª¿æ•´ webcam.js æ“·å–é »ç‡å¾ 1000ms åˆ° 500ms

å¦‚ä½•ç¢ºä¿è¾¨è­˜+æ ¡æ­£æ™‚é–“èƒ½åœ¨500mså…§å®Œæˆ?

/1 

--- Cursor Command: 1.md ---
è«‹åŒæ™‚ä½¿ç”¨ /ddg-search /context7 /sequential-thinking è§£æ±ºæˆ–å›ç­”å•é¡Œ
--- End Command ---

---

**Cursor**

é€™æ˜¯å€‹å¾ˆå¥½çš„å•é¡Œï¼è®“æˆ‘æ·±å…¥ç ”ç©¶ DocAligner çš„æ•ˆèƒ½ç‰¹æ€§å’Œå„ªåŒ–æ–¹æ¡ˆã€‚

æ ¹æ“šæ·±åº¦ç ”ç©¶ï¼Œæˆ‘å¯ä»¥çµ¦æ‚¨ä»¥ä¸‹åˆ†æï¼š

## æ•ˆèƒ½åˆ†æçµè«–

### è™•ç†æ™‚é–“é ä¼°

| æ­¥é©Ÿ | æ™‚é–“ |
|------|------|
| Base64 è§£ç¢¼ | ~10ms |
| cv2.imdecode | ~20ms |
| **DocAligner åµæ¸¬** | **~100ms** (CPU) |
| imwarp_quadrangle æ ¡æ­£ | ~30ms |
| Base64 ç·¨ç¢¼çµæœ | ~20ms |
| **ç¸½è¨ˆ** | **~180ms** |

**âœ… 500ms é–“éš”å®Œå…¨è¶³å¤ ï¼** ç”šè‡³é‚„æœ‰ 300ms çš„ç·©è¡ç©ºé–“ã€‚

---

### ç¢ºä¿æ•ˆèƒ½çš„é—œéµç­–ç•¥

**1. æ¨¡å‹é è¼‰å…¥ï¼ˆå¿…é ˆï¼‰**

DocAligner é¦–æ¬¡èª¿ç”¨æœƒè¼‰å…¥æ¨¡å‹ï¼ˆéœ€è¦æ•¸ç§’ï¼‰ï¼Œå¿…é ˆåœ¨æ‡‰ç”¨å•Ÿå‹•æ™‚é å…ˆåˆå§‹åŒ–ï¼š

```python
# åœ¨ main.py é ‚éƒ¨åˆå§‹åŒ–ï¼Œå†·å•Ÿå‹•æ™‚è¼‰å…¥æ¨¡å‹
DOC_ALIGNER = DocAligner()
```

**2. é˜²æ­¢å¹€å †ç©ï¼ˆå»ºè­°ï¼‰**

åŠ å…¥è™•ç†é–ï¼Œé¿å…å‰ä¸€å¹€é‚„æ²’è™•ç†å®Œå°±æ”¶åˆ°ä¸‹ä¸€å¹€ï¼š

```python
is_processing = False

def on_frame_received(base64_data):
    nonlocal is_processing
    if is_processing:
        return  # è·³éé€™å¹€
    is_processing = True
    # ... è™•ç†é‚è¼¯ ...
    is_processing = False
```

**3. å¯é¸é€²éšå„ªåŒ–**

æ ¹æ“šå®˜æ–¹æ–‡æª”ï¼Œå¦‚æœéœ€è¦æ›´å¿«é€Ÿåº¦ï¼š

```python
from capybara import Backend

# GPU åŠ é€Ÿï¼ˆå¦‚æœæœ‰ NVIDIA é¡¯å¡ï¼‰
DOC_ALIGNER = DocAligner(backend=Backend.cuda)

# æ›´è¼•é‡çš„æ¨¡å‹é…ç½®
DOC_ALIGNER = DocAligner(model_cfg='fastvit_t8')

# ä½¿ç”¨ center_crop æé«˜æ•ˆç‡ï¼ˆé‡å°éæ­£æ–¹å½¢åœ–ç‰‡ï¼‰
poly_arr = DOC_ALIGNER(img=bgr_img, do_center_crop=True)
```

---

### æ›´æ–°è¨ˆç•«

æ˜¯å¦è¦æˆ‘å°‡é€™äº›æ•ˆèƒ½å„ªåŒ–ç­–ç•¥åŠ å…¥å¯¦ä½œè¨ˆç•«ä¸­ï¼Ÿ

```python
# åœ¨ main.py é ‚éƒ¨åˆå§‹åŒ–ï¼Œå†·å•Ÿå‹•æ™‚è¼‰å…¥æ¨¡å‹
DOC_ALIGNER = DocAligner()
```

```python
is_processing = False

def on_frame_received(base64_data):
    nonlocal is_processing
    if is_processing:
        return  # è·³éé€™å¹€
    is_processing = True
    # ... è™•ç†é‚è¼¯ ...
    is_processing = False
```

```python
from capybara import Backend

# GPU åŠ é€Ÿï¼ˆå¦‚æœæœ‰ NVIDIA é¡¯å¡ï¼‰
DOC_ALIGNER = DocAligner(backend=Backend.cuda)

# æ›´è¼•é‡çš„æ¨¡å‹é…ç½®
DOC_ALIGNER = DocAligner(model_cfg='fastvit_t8')

# ä½¿ç”¨ center_crop æé«˜æ•ˆç‡ï¼ˆé‡å°éæ­£æ–¹å½¢åœ–ç‰‡ï¼‰
poly_arr = DOC_ALIGNER(img=bgr_img, do_center_crop=True)
```

å¥½çš„ï¼æ‚¨é¸æ“‡ä½¿ç”¨ CPU ä¸¦ç¢ºèªé–‹å§‹å¯¦ä½œã€‚è®“æˆ‘æ›´æ–°è¨ˆç•«ä¸¦åŠ å…¥æ•ˆèƒ½å„ªåŒ–ç­–ç•¥ï¼š

---

**User**

Implement the plan as specified, it is attached for your reference. Do NOT edit the plan file itself.

To-do's from the plan have already been created. Do not create them again. Mark them as in_progress as you work, starting with the first one. Don't stop until you have completed all the to-dos.

---

**Cursor**

å¥½çš„ï¼æˆ‘ç¾åœ¨é–‹å§‹å¯¦ä½œè¨ˆç•«ã€‚é¦–å…ˆæ¨™è¨˜ç¬¬ä¸€å€‹å¾…è¾¦äº‹é …ç‚ºé€²è¡Œä¸­ï¼Œä¸¦æ›´æ–° pyproject.tomlã€‚

```toml
[project]
name = "webcam-nicegui"
version = "0.1.0"
description = "Add your description here"
readme = "README.md"
requires-python = ">=3.13"
dependencies = [
    "cryptography>=46.0.3",
    "docaligner-docsaid>=1.1.0",
    "loguru>=0.7.3",
    "nicegui>=3.3.1",
    "opencv-python>=4.0",
    "scikit-image>=0.25.2",
]

```

ç¾åœ¨æˆ‘è¦å®Œå…¨é‡å¯« main.pyï¼Œæ•´åˆ DocAligner åµæ¸¬ã€é€è¦–æ ¡æ­£ã€UI ç‹€æ…‹ç®¡ç†ï¼š

```python
import base64
from datetime import datetime
from io import BytesIO
from pathlib import Path

import cv2
import numpy as np
from capybara import imwarp_quadrangle
from docaligner import DocAligner
from loguru import logger
from nicegui import app, ui

# è¨­å®šåœ–ç‰‡å„²å­˜è·¯å¾‘
IMAGES_DIR = Path(__file__).parent / "images"
IMAGES_DIR.mkdir(exist_ok=True)

# æœ€å¤šä¿ç•™çš„åœ–ç‰‡æ•¸é‡
MAX_IMAGES_COUNT = 30

# è¼¸å‡ºå°ºå¯¸è¨­å®šï¼ˆå¯¬åº¦å›ºå®šï¼Œé«˜åº¦æŒ‰æ¯”ä¾‹ï¼‰
OUTPUT_WIDTH_INT = 800

# åˆå§‹åŒ– DocAlignerï¼ˆå†·å•Ÿå‹•æ™‚è¼‰å…¥æ¨¡å‹ï¼Œé¿å…é¦–æ¬¡åµæ¸¬å»¶é²ï¼‰
logger.info("æ­£åœ¨è¼‰å…¥ DocAligner æ¨¡å‹...")
DOC_ALIGNER = DocAligner()
logger.info("DocAligner æ¨¡å‹è¼‰å…¥å®Œæˆï¼")


def cleanup_old_images() -> None:
    image_path_list = sorted(
        IMAGES_DIR.glob("*.jpg"),
        key=lambda p: p.stat().st_mtime,
    )
    while len(image_path_list) > MAX_IMAGES_COUNT:
        oldest_path = image_path_list.pop(0)
        oldest_path.unlink()
        logger.info(f"å·²åˆªé™¤èˆŠåœ–ç‰‡: {oldest_path.name}")


def decode_base64_image(base64_data: str) -> np.ndarray | None:
    try:
        # ç§»é™¤ base64 header (data:image/jpeg;base64,)
        if "," in base64_data:
            base64_data = base64_data.split(",")[1]

        # è§£ç¢¼ base64 ç‚º bytes
        image_bytes = base64.b64decode(base64_data)

        # è½‰æ›ç‚º numpy array
        nparr = np.frombuffer(image_bytes, np.uint8)

        # è§£ç¢¼ç‚º BGR åœ–ç‰‡
        bgr_img = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
        return bgr_img
    except Exception as e:
        logger.error(f"è§£ç¢¼åœ–ç‰‡å¤±æ•—: {e}")
        return None


def encode_image_to_base64(rgb_img: np.ndarray) -> str:
    # è½‰æ› RGB åˆ° BGR
    bgr_img = cv2.cvtColor(rgb_img, cv2.COLOR_RGB2BGR)

    # ç·¨ç¢¼ç‚º JPEG
    success_bool, buffer = cv2.imencode(
        ".jpg",
        bgr_img,
        [cv2.IMWRITE_JPEG_QUALITY, 90],
    )
    if not success_bool:
        raise ValueError("åœ–ç‰‡ç·¨ç¢¼å¤±æ•—")

    # è½‰æ›ç‚º base64
    base64_str = base64.b64encode(buffer).decode("utf-8")
    return f"data:image/jpeg;base64,{base64_str}"


def calculate_output_size(
    img_height_int: int,
    img_width_int: int,
    target_width_int: int = OUTPUT_WIDTH_INT,
) -> tuple[int, int]:
    aspect_ratio_num = img_height_int / img_width_int
    target_height_int = int(target_width_int * aspect_ratio_num)
    return (target_width_int, target_height_int)


def process_card_detection(bgr_img: np.ndarray) -> tuple[bool, np.ndarray | None]:
    try:
        # åµæ¸¬è­‰ä»¶/å¡ç‰‡
        poly_arr = DOC_ALIGNER(img=bgr_img, do_center_crop=True)

        if len(poly_arr) != 4:
            return False, None

        logger.info("åµæ¸¬åˆ°å¡ç‰‡ï¼æ­£åœ¨é€²è¡Œé€è¦–æ ¡æ­£...")

        # è½‰æ› BGR åˆ° RGB
        rgb_img = cv2.cvtColor(bgr_img, cv2.COLOR_BGR2RGB)

        # è¨ˆç®—è¼¸å‡ºå°ºå¯¸
        img_height_int, img_width_int = rgb_img.shape[:2]
        output_width_int, output_height_int = calculate_output_size(
            img_height_int=img_height_int,
            img_width_int=img_width_int,
            target_width_int=OUTPUT_WIDTH_INT,
        )

        # é€è¦–æ ¡æ­£
        flat_rgb_img = imwarp_quadrangle(
            img=rgb_img,
            polygon=poly_arr,
            dst_size=(output_width_int, output_height_int),
        )

        return True, flat_rgb_img

    except Exception as e:
        logger.error(f"å¡ç‰‡åµæ¸¬/æ ¡æ­£éŒ¯èª¤: {e}")
        return False, None


def save_corrected_image(rgb_img: np.ndarray) -> Path | None:
    try:
        timestamp_str = datetime.now().strftime("%Y%m%d_%H%M%S_%f")
        filename = f"corrected_{timestamp_str}.jpg"
        filepath = IMAGES_DIR / filename

        # è½‰æ› RGB åˆ° BGR ä¸¦å„²å­˜
        bgr_img = cv2.cvtColor(rgb_img, cv2.COLOR_RGB2BGR)
        cv2.imwrite(str(filepath), bgr_img, [cv2.IMWRITE_JPEG_QUALITY, 95])

        logger.info(f"å·²å„²å­˜æ ¡æ­£å¾Œåœ–ç‰‡: {filename}")
        cleanup_old_images()
        return filepath
    except Exception as e:
        logger.error(f"å„²å­˜åœ–ç‰‡å¤±æ•—: {e}")
        return None


# è¨­å®šéœæ…‹æª”æ¡ˆè·¯å¾‘
app.add_static_files("/static", Path(__file__).parent / "static")


@ui.page("/")
def index_page():
    # é é¢ç‹€æ…‹ï¼ˆæ¯å€‹ client ç¨ç«‹ï¼‰
    is_processing = False
    is_detected = False

    ui.add_head_html('<script src="/static/webcam.js"></script>')

    with ui.column().classes("w-full items-center p-4"):
        ui.label("ğŸ“· å¡ç‰‡æ“·å–èˆ‡æ ¡æ­£").classes("text-2xl font-bold mb-4")

        # å½±åƒé è¦½å€åŸŸï¼ˆåµæ¸¬ä¸­é¡¯ç¤ºï¼‰
        video_card = ui.card().classes("w-full max-w-lg")
        with video_card:
            ui.html(
                '<video id="webcam-video" autoplay playsinline muted '
                'style="width: 100%; border-radius: 8px; background: #000;"></video>',
                sanitize=False,
            )

        # çµæœåœ–ç‰‡å€åŸŸï¼ˆåµæ¸¬æˆåŠŸå¾Œé¡¯ç¤ºï¼‰
        result_card = ui.card().classes("w-full max-w-lg hidden")
        with result_card:
            result_image = ui.image().classes("w-full rounded-lg")

        # ç‹€æ…‹é¡¯ç¤º
        status_label = ui.label("ç‹€æ…‹ï¼šç­‰å¾…å•Ÿå‹•æ”åƒé ­...").classes("mt-4 text-gray-600")

        # é‡æ–°æ‹æ”æŒ‰éˆ•ï¼ˆåˆå§‹éš±è—ï¼‰
        retry_button = ui.button(
            "é‡æ–°æ‹æ”",
            on_click=lambda: ui.run_javascript("location.reload()"),
        ).classes("mt-4 hidden").props("color=primary size=lg")

        # å®šç¾©æ¥æ”¶åœ–ç‰‡çš„è™•ç†å‡½æ•¸
        def on_frame_received(base64_data: str) -> None:
            nonlocal is_processing, is_detected

            # å¦‚æœå·²ç¶“åµæ¸¬æˆåŠŸæˆ–æ­£åœ¨è™•ç†ï¼Œè·³éé€™å¹€
            if is_detected or is_processing:
                return

            if not base64_data or not isinstance(base64_data, str):
                return

            is_processing = True

            try:
                # è§£ç¢¼åœ–ç‰‡
                bgr_img = decode_base64_image(base64_data)
                if bgr_img is None:
                    return

                # åµæ¸¬ä¸¦æ ¡æ­£å¡ç‰‡
                success_bool, flat_rgb_img = process_card_detection(bgr_img)

                if success_bool and flat_rgb_img is not None:
                    is_detected = True

                    # å„²å­˜æ ¡æ­£å¾Œçš„åœ–ç‰‡
                    save_corrected_image(flat_rgb_img)

                    # ç·¨ç¢¼çµæœåœ–ç‰‡ç‚º base64
                    result_base64 = encode_image_to_base64(flat_rgb_img)

                    # æ›´æ–°å‰ç«¯ UI
                    status_label.set_text("ç‹€æ…‹ï¼šå¡ç‰‡æ“·å–æˆåŠŸï¼")

                    # åœæ­¢ webcam æ“·å–
                    ui.run_javascript("WebcamCapture.stopCapture();")

                    # éš±è— videoï¼Œé¡¯ç¤ºçµæœ
                    video_card.classes(add="hidden")
                    result_card.classes(remove="hidden")
                    result_image.set_source(result_base64)

                    # é¡¯ç¤ºé‡æ–°æ‹æ”æŒ‰éˆ•
                    retry_button.classes(remove="hidden")

            finally:
                is_processing = False

        # ä½¿ç”¨å…¨åŸŸäº‹ä»¶ç›£è½
        ui.on("webcam_frame", lambda e: on_frame_received(e.args))

        # åˆå§‹åŒ–æ”åƒé ­ä¸¦è‡ªå‹•é–‹å§‹æ“·å–
        async def init_camera():
            try:
                result = await ui.run_javascript(
                    """
                    (async () => {
                        const success = await WebcamCapture.init('webcam-video');
                        if (success) {
                            WebcamCapture.startCapture((frameData) => {
                                emitEvent('webcam_frame', frameData);
                            });
                        }
                        return success;
                    })()
                    """,
                    timeout=10.0,
                )
                if result:
                    status_label.set_text("ç‹€æ…‹ï¼šåµæ¸¬ä¸­ï¼Œè«‹å°‡å¡ç‰‡å°æº–é¡é ­...")
                else:
                    status_label.set_text("ç‹€æ…‹ï¼šç„¡æ³•å­˜å–æ”åƒé ­ï¼Œè«‹ç¢ºèªæ¬Šé™è¨­å®š")
                return result
            except TimeoutError:
                status_label.set_text("ç‹€æ…‹ï¼šç­‰å¾…é€£ç·šä¸­...")
                logger.warning("JavaScript åˆå§‹åŒ–è¶…æ™‚ï¼Œç­‰å¾…å®¢æˆ¶ç«¯é€£æ¥")
                return False

        # é é¢è¼‰å…¥å¾Œè‡ªå‹•åˆå§‹åŒ–æ”åƒé ­
        ui.timer(0.5, init_camera, once=True)


def main():
    port_int = 25331
    logger.info(f"å•Ÿå‹•å¡ç‰‡æ“·å–èˆ‡æ ¡æ­£ï¼Œç«¯å£: {port_int}")

    ui.run(
        host="0.0.0.0",
        port=port_int,
        title="å¡ç‰‡æ“·å–èˆ‡æ ¡æ­£",
        reload=False,
    )


if __name__ in {"__main__", "__mp_main__"}:
    main()

```

```python
import base64
from datetime import datetime
from pathlib import Path

import cv2
import numpy as np
from capybara import imwarp_quadrangle
from docaligner import DocAligner
from loguru import logger
from nicegui import app, ui

# è¨­å®šåœ–ç‰‡å„²å­˜è·¯å¾‘
IMAGES_DIR = Path(__file__).parent / "images"
IMAGES_DIR.mkdir(exist_ok=True)

# æœ€å¤šä¿ç•™çš„åœ–ç‰‡æ•¸é‡
MAX_IMAGES_COUNT = 30

# è¼¸å‡ºå°ºå¯¸è¨­å®šï¼ˆå¯¬åº¦å›ºå®šï¼Œé«˜åº¦æŒ‰æ¯”ä¾‹ï¼‰
OUTPUT_WIDTH_INT = 800

# åˆå§‹åŒ– DocAlignerï¼ˆå†·å•Ÿå‹•æ™‚è¼‰å…¥æ¨¡å‹ï¼Œé¿å…é¦–æ¬¡åµæ¸¬å»¶é²ï¼‰
logger.info("æ­£åœ¨è¼‰å…¥ DocAligner æ¨¡å‹...")
DOC_ALIGNER = DocAligner()
logger.info("DocAligner æ¨¡å‹è¼‰å…¥å®Œæˆï¼")


def cleanup_old_images() -> None:
    image_path_list = sorted(
        IMAGES_DIR.glob("*.jpg"),
        key=lambda p: p.stat().st_mtime,
    )
    while len(image_path_list) > MAX_IMAGES_COUNT:
        oldest_path = image_path_list.pop(0)
        oldest_path.unlink()
        logger.info(f"å·²åˆªé™¤èˆŠåœ–ç‰‡: {oldest_path.name}")


def decode_base64_image(base64_data: str) -> np.ndarray | None:
    try:
        # ç§»é™¤ base64 header (data:image/jpeg;base64,)
        if "," in base64_data:
            base64_data = base64_data.split(",")[1]

        # è§£ç¢¼ base64 ç‚º bytes
        image_bytes = base64.b64decode(base64_data)

        # è½‰æ›ç‚º numpy array
        nparr = np.frombuffer(image_bytes, np.uint8)

        # è§£ç¢¼ç‚º BGR åœ–ç‰‡
        bgr_img = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
        return bgr_img
    except Exception as e:
        logger.error(f"è§£ç¢¼åœ–ç‰‡å¤±æ•—: {e}")
        return None


def encode_image_to_base64(rgb_img: np.ndarray) -> str:
    # è½‰æ› RGB åˆ° BGR
    bgr_img = cv2.cvtColor(rgb_img, cv2.COLOR_RGB2BGR)

    # ç·¨ç¢¼ç‚º JPEG
    success_bool, buffer = cv2.imencode(
        ".jpg",
        bgr_img,
        [cv2.IMWRITE_JPEG_QUALITY, 90],
    )
    if not success_bool:
        raise ValueError("åœ–ç‰‡ç·¨ç¢¼å¤±æ•—")

    # è½‰æ›ç‚º base64
    base64_str = base64.b64encode(buffer).decode("utf-8")
    return f"data:image/jpeg;base64,{base64_str}"


def calculate_output_size(
    img_height_int: int,
    img_width_int: int,
    target_width_int: int = OUTPUT_WIDTH_INT,
) -> tuple[int, int]:
    aspect_ratio_num = img_height_int / img_width_int
    target_height_int = int(target_width_int * aspect_ratio_num)
    return (target_width_int, target_height_int)


def process_card_detection(bgr_img: np.ndarray) -> tuple[bool, np.ndarray | None]:
    try:
        # åµæ¸¬è­‰ä»¶/å¡ç‰‡
        poly_arr = DOC_ALIGNER(img=bgr_img, do_center_crop=True)

        if len(poly_arr) != 4:
            return False, None

        logger.info("åµæ¸¬åˆ°å¡ç‰‡ï¼æ­£åœ¨é€²è¡Œé€è¦–æ ¡æ­£...")

        # è½‰æ› BGR åˆ° RGB
        rgb_img = cv2.cvtColor(bgr_img, cv2.COLOR_BGR2RGB)

        # è¨ˆç®—è¼¸å‡ºå°ºå¯¸
        img_height_int, img_width_int = rgb_img.shape[:2]
        output_width_int, output_height_int = calculate_output_size(
            img_height_int=img_height_int,
            img_width_int=img_width_int,
            target_width_int=OUTPUT_WIDTH_INT,
        )

        # é€è¦–æ ¡æ­£
        flat_rgb_img = imwarp_quadrangle(
            img=rgb_img,
            polygon=poly_arr,
            dst_size=(output_width_int, output_height_int),
        )

        return True, flat_rgb_img

    except Exception as e:
        logger.error(f"å¡ç‰‡åµæ¸¬/æ ¡æ­£éŒ¯èª¤: {e}")
        return False, None


def save_corrected_image(rgb_img: np.ndarray) -> Path | None:
    try:
        timestamp_str = datetime.now().strftime("%Y%m%d_%H%M%S_%f")
        filename = f"corrected_{timestamp_str}.jpg"
        filepath = IMAGES_DIR / filename

        # è½‰æ› RGB åˆ° BGR ä¸¦å„²å­˜
        bgr_img = cv2.cvtColor(rgb_img, cv2.COLOR_RGB2BGR)
        cv2.imwrite(str(filepath), bgr_img, [cv2.IMWRITE_JPEG_QUALITY, 95])

        logger.info(f"å·²å„²å­˜æ ¡æ­£å¾Œåœ–ç‰‡: {filename}")
        cleanup_old_images()
        return filepath
    except Exception as e:
        logger.error(f"å„²å­˜åœ–ç‰‡å¤±æ•—: {e}")
        return None


# è¨­å®šéœæ…‹æª”æ¡ˆè·¯å¾‘
app.add_static_files("/static", Path(__file__).parent / "static")


@ui.page("/")
def index_page():
    # é é¢ç‹€æ…‹ï¼ˆæ¯å€‹ client ç¨ç«‹ï¼‰
    is_processing = False
    is_detected = False

    ui.add_head_html('<script src="/static/webcam.js"></script>')

    with ui.column().classes("w-full items-center p-4"):
        ui.label("ğŸ“· å¡ç‰‡æ“·å–èˆ‡æ ¡æ­£").classes("text-2xl font-bold mb-4")

        # å½±åƒé è¦½å€åŸŸï¼ˆåµæ¸¬ä¸­é¡¯ç¤ºï¼‰
        video_card = ui.card().classes("w-full max-w-lg")
        with video_card:
            ui.html(
                '<video id="webcam-video" autoplay playsinline muted '
                'style="width: 100%; border-radius: 8px; background: #000;"></video>',
                sanitize=False,
            )

        # çµæœåœ–ç‰‡å€åŸŸï¼ˆåµæ¸¬æˆåŠŸå¾Œé¡¯ç¤ºï¼‰
        result_card = ui.card().classes("w-full max-w-lg hidden")
        with result_card:
            result_image = ui.image().classes("w-full rounded-lg")

        # ç‹€æ…‹é¡¯ç¤º
        status_label = ui.label("ç‹€æ…‹ï¼šç­‰å¾…å•Ÿå‹•æ”åƒé ­...").classes("mt-4 text-gray-600")

        # é‡æ–°æ‹æ”æŒ‰éˆ•ï¼ˆåˆå§‹éš±è—ï¼‰
        retry_button = ui.button(
            "é‡æ–°æ‹æ”",
            on_click=lambda: ui.run_javascript("location.reload()"),
        ).classes("mt-4 hidden").props("color=primary size=lg")

        # å®šç¾©æ¥æ”¶åœ–ç‰‡çš„è™•ç†å‡½æ•¸
        def on_frame_received(base64_data: str) -> None:
            nonlocal is_processing, is_detected

            # å¦‚æœå·²ç¶“åµæ¸¬æˆåŠŸæˆ–æ­£åœ¨è™•ç†ï¼Œè·³éé€™å¹€
            if is_detected or is_processing:
                return

            if not base64_data or not isinstance(base64_data, str):
                return

            is_processing = True

            try:
                # è§£ç¢¼åœ–ç‰‡
                bgr_img = decode_base64_image(base64_data)
                if bgr_img is None:
                    return

                # åµæ¸¬ä¸¦æ ¡æ­£å¡ç‰‡
                success_bool, flat_rgb_img = process_card_detection(bgr_img)

                if success_bool and flat_rgb_img is not None:
                    is_detected = True

                    # å„²å­˜æ ¡æ­£å¾Œçš„åœ–ç‰‡
                    save_corrected_image(flat_rgb_img)

                    # ç·¨ç¢¼çµæœåœ–ç‰‡ç‚º base64
                    result_base64 = encode_image_to_base64(flat_rgb_img)

                    # æ›´æ–°å‰ç«¯ UI
                    status_label.set_text("ç‹€æ…‹ï¼šå¡ç‰‡æ“·å–æˆåŠŸï¼")

                    # åœæ­¢ webcam æ“·å–
                    ui.run_javascript("WebcamCapture.stopCapture();")

                    # éš±è— videoï¼Œé¡¯ç¤ºçµæœ
                    video_card.classes(add="hidden")
                    result_card.classes(remove="hidden")
                    result_image.set_source(result_base64)

                    # é¡¯ç¤ºé‡æ–°æ‹æ”æŒ‰éˆ•
                    retry_button.classes(remove="hidden")

            finally:
                is_processing = False

        # ä½¿ç”¨å…¨åŸŸäº‹ä»¶ç›£è½
        ui.on("webcam_frame", lambda e: on_frame_received(e.args))

        # åˆå§‹åŒ–æ”åƒé ­ä¸¦è‡ªå‹•é–‹å§‹æ“·å–
        async def init_camera():
            try:
                result = await ui.run_javascript(
                    """
                    (async () => {
                        const success = await WebcamCapture.init('webcam-video');
                        if (success) {
                            WebcamCapture.startCapture((frameData) => {
                                emitEvent('webcam_frame', frameData);
                            });
                        }
                        return success;
                    })()
                    """,
                    timeout=10.0,
                )
                if result:
                    status_label.set_text("ç‹€æ…‹ï¼šåµæ¸¬ä¸­ï¼Œè«‹å°‡å¡ç‰‡å°æº–é¡é ­...")
                else:
                    status_label.set_text("ç‹€æ…‹ï¼šç„¡æ³•å­˜å–æ”åƒé ­ï¼Œè«‹ç¢ºèªæ¬Šé™è¨­å®š")
                return result
            except TimeoutError:
                status_label.set_text("ç‹€æ…‹ï¼šç­‰å¾…é€£ç·šä¸­...")
                logger.warning("JavaScript åˆå§‹åŒ–è¶…æ™‚ï¼Œç­‰å¾…å®¢æˆ¶ç«¯é€£æ¥")
                return False

        # é é¢è¼‰å…¥å¾Œè‡ªå‹•åˆå§‹åŒ–æ”åƒé ­
        ui.timer(0.5, init_camera, once=True)


def main():
    port_int = 25331
    logger.info(f"å•Ÿå‹•å¡ç‰‡æ“·å–èˆ‡æ ¡æ­£ï¼Œç«¯å£: {port_int}")

    ui.run(
        host="0.0.0.0",
        port=port_int,
        title="å¡ç‰‡æ“·å–èˆ‡æ ¡æ­£",
        reload=False,
    )


if __name__ in {"__main__", "__mp_main__"}:
    main()

```

```javascript
// Webcam capture and streaming module
// æ”åƒé ­æ“·å–èˆ‡ä¸²æµæ¨¡çµ„

const WebcamCapture = {
    video: null,
    canvas: null,
    ctx: null,
    stream: null,
    isCapturing: false,
    captureInterval: null,
    maxWidth: 800,
    jpegQuality: 0.7,

    // åˆå§‹åŒ–æ”åƒé ­
    async init(videoElementId) {
        this.video = document.getElementById(videoElementId);
        this.canvas = document.createElement('canvas');
        this.ctx = this.canvas.getContext('2d');

        try {
            // å„ªå…ˆä½¿ç”¨å¾Œç½®é¡é ­
            this.stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    facingMode: 'environment',
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                },
                audio: false
            });

            this.video.srcObject = this.stream;
            await this.video.play();
            console.log('æ”åƒé ­å·²å•Ÿå‹•');
            return true;
        } catch (error) {
            console.error('ç„¡æ³•å­˜å–æ”åƒé ­:', error);
            // å˜—è©¦ä½¿ç”¨ä»»ä½•å¯ç”¨çš„æ”åƒé ­
            try {
                this.stream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: false
                });
                this.video.srcObject = this.stream;
                await this.video.play();
                console.log('æ”åƒé ­å·²å•Ÿå‹•ï¼ˆå‚™ç”¨æ¨¡å¼ï¼‰');
                return true;
            } catch (fallbackError) {
                console.error('ç„¡æ³•å­˜å–ä»»ä½•æ”åƒé ­:', fallbackError);
                return false;
            }
        }
    },

    // æ“·å–ä¸¦å£“ç¸®ç•«é¢
    captureFrame() {
        if (!this.video || !this.video.videoWidth) {
            return null;
        }

        // è¨ˆç®—å£“ç¸®å¾Œçš„å°ºå¯¸
        let width = this.video.videoWidth;
        let height = this.video.videoHeight;

        if (width > this.maxWidth) {
            const ratio = this.maxWidth / width;
            width = this.maxWidth;
            height = Math.round(height * ratio);
        }

        // è¨­å®š canvas å°ºå¯¸ä¸¦ç¹ªè£½
        this.canvas.width = width;
        this.canvas.height = height;
        this.ctx.drawImage(this.video, 0, 0, width, height);

        // è½‰æ›ç‚º JPEG base64
        const base64Data = this.canvas.toDataURL('image/jpeg', this.jpegQuality);
        return base64Data;
    },

    // é–‹å§‹æ“·å–ï¼ˆæ¯ç§’ä¸€æ¬¡ï¼‰
    startCapture(onCaptureCallback) {
        if (this.isCapturing) {
            console.log('å·²ç¶“åœ¨æ“·å–ä¸­');
            return;
        }

        this.isCapturing = true;
        this.captureInterval = setInterval(() => {
            const frameData = this.captureFrame();
            if (frameData && onCaptureCallback) {
                onCaptureCallback(frameData);
            }
        }, 500);  // æ¯ 500ms ä¸€æ¬¡ï¼ˆæé«˜åµæ¸¬éŸ¿æ‡‰é€Ÿåº¦ï¼‰

        console.log('é–‹å§‹æ“·å–ç•«é¢');
    },

    // åœæ­¢æ“·å–
    stopCapture() {
        if (this.captureInterval) {
            clearInterval(this.captureInterval);
            this.captureInterval = null;
        }
        this.isCapturing = false;
        console.log('åœæ­¢æ“·å–ç•«é¢');
    },

    // åœæ­¢æ”åƒé ­
    stop() {
        this.stopCapture();
        if (this.stream) {
            this.stream.getTracks().forEach(track => track.stop());
            this.stream = null;
        }
        if (this.video) {
            this.video.srcObject = null;
        }
        console.log('æ”åƒé ­å·²åœæ­¢');
    },

    // è¨­å®šå£“ç¸®åƒæ•¸
    setCompression(maxWidth, jpegQuality) {
        this.maxWidth = maxWidth || 800;
        this.jpegQuality = jpegQuality || 0.7;
    }
};

// å°‡æ¨¡çµ„æš´éœ²åˆ°å…¨åŸŸ
window.WebcamCapture = WebcamCapture;



```

ç¾åœ¨åŒæ­¥ä¾è³´ä¸¦é‹è¡Œæ¸¬è©¦ï¼š

è®“æˆ‘æª¢æŸ¥ä¸€ä¸‹ç•¶å‰çµ‚ç«¯çš„ç‹€æ…‹ï¼š

è®“æˆ‘é‡æ–°é‹è¡Œæ‡‰ç”¨ï¼Œé€™æ¬¡ç”¨éèƒŒæ™¯æ¨¡å¼ä¾†çœ‹å®Œæ•´è¼¸å‡ºï¼š

è®“æˆ‘ç”¨å¦ä¸€ç¨®æ–¹å¼ä¾†å•Ÿå‹•æ‡‰ç”¨ï¼š

è®“æˆ‘ä½¿ç”¨ Chrome DevTools ä¾†æ¸¬è©¦æ‡‰ç”¨ï¼š

æ‡‰ç”¨æ²’æœ‰é‹è¡Œã€‚è®“æˆ‘å˜—è©¦ç›´æ¥é‹è¡Œä¸¦æŸ¥çœ‹éŒ¯èª¤ï¼š

è®“æˆ‘å…ˆç¢ºèªä¾è³´å®‰è£ç‹€æ…‹ï¼š

è®“æˆ‘æª¢æŸ¥ä¾è³´æ˜¯å¦æ­£ç¢ºé…ç½®ï¼š

éœ€è¦æ›´æ–° lock æ–‡ä»¶ã€‚è®“æˆ‘é‡æ–°ç”Ÿæˆï¼š

---

**User**

(webcam_nicegui_venv) > uv run main.py 



Traceback (most recent call last):

  File "G:\æˆ‘çš„é›²ç«¯ç¡¬ç¢Ÿ\å ´å¤–ç”¨\251125 webcam_nicegui\main.py", line 7, in <module>

    from capybara import imwarp_quadrangle

  File "C:\Users\pappl\venvs\webcam_nicegui_venv\Lib\site-packages\capybara\__init__.py", line 3, in <module>

    from .onnxengine import *

  File "C:\Users\pappl\venvs\webcam_nicegui_venv\Lib\site-packages\capybara\onnxengine\__init__.py", line 1, in <module>

    from .engine import ONNXEngine

  File "C:\Users\pappl\venvs\webcam_nicegui_venv\Lib\site-packages\capybara\onnxengine\engine.py", line 6, in <module>

    import onnxruntime as ort

ModuleNotFoundError: No module named 'onnxruntime'

2025-11-27 18:39:52 G:\..\å ´å¤–ç”¨\251125 webcam_nicegui ( 2.79 s)

(webcam_nicegui_venv) >

/1 

--- Cursor Command: 1.md ---
è«‹åŒæ™‚ä½¿ç”¨ /ddg-search /context7 /sequential-thinking è§£æ±ºæˆ–å›ç­”å•é¡Œ
--- End Command ---

---

**Cursor**

éœ€è¦å®‰è£ `onnxruntime`ã€‚è®“æˆ‘å¿«é€Ÿä¿®å¾©ï¼š

```toml
[project]
name = "webcam-nicegui"
version = "0.1.0"
description = "Add your description here"
readme = "README.md"
requires-python = ">=3.13"
dependencies = [
    "cryptography>=46.0.3",
    "docaligner-docsaid>=1.1.0",
    "loguru>=0.7.3",
    "nicegui>=3.3.1",
    "onnxruntime>=1.18.0",
    "opencv-python>=4.0",
    "scikit-image>=0.25.2",
]

```

ç¾åœ¨é‹è¡Œæ‡‰ç”¨ï¼š

---

**User**

æˆ‘é¡é ­å°äº†åŠå¤©éƒ½æ²’æœ‰é¡¯ç¤ºçµæœ

èƒ½å¹«æˆ‘è¿½åŠ debugè³‡è¨Šå—?

---

**Cursor**

å¥½çš„ï¼è®“æˆ‘å¢åŠ  debug è³‡è¨Šä¾†è¿½è¹¤åµæ¸¬æµç¨‹ï¼š

```python
import base64
from datetime import datetime
from pathlib import Path

import cv2
import numpy as np
from capybara import imwarp_quadrangle
from docaligner import DocAligner
from loguru import logger
from nicegui import app, ui

# è¨­å®šåœ–ç‰‡å„²å­˜è·¯å¾‘
IMAGES_DIR = Path(__file__).parent / "images"
IMAGES_DIR.mkdir(exist_ok=True)

# æœ€å¤šä¿ç•™çš„åœ–ç‰‡æ•¸é‡
MAX_IMAGES_COUNT = 30

# è¼¸å‡ºå°ºå¯¸è¨­å®šï¼ˆå¯¬åº¦å›ºå®šï¼Œé«˜åº¦æŒ‰æ¯”ä¾‹ï¼‰
OUTPUT_WIDTH_INT = 800

# åˆå§‹åŒ– DocAlignerï¼ˆå†·å•Ÿå‹•æ™‚è¼‰å…¥æ¨¡å‹ï¼Œé¿å…é¦–æ¬¡åµæ¸¬å»¶é²ï¼‰
logger.info("æ­£åœ¨è¼‰å…¥ DocAligner æ¨¡å‹...")
DOC_ALIGNER = DocAligner()
logger.info("DocAligner æ¨¡å‹è¼‰å…¥å®Œæˆï¼")


def cleanup_old_images() -> None:
    image_path_list = sorted(
        IMAGES_DIR.glob("*.jpg"),
        key=lambda p: p.stat().st_mtime,
    )
    while len(image_path_list) > MAX_IMAGES_COUNT:
        oldest_path = image_path_list.pop(0)
        oldest_path.unlink()
        logger.info(f"å·²åˆªé™¤èˆŠåœ–ç‰‡: {oldest_path.name}")


def decode_base64_image(base64_data: str) -> np.ndarray | None:
    try:
        # ç§»é™¤ base64 header (data:image/jpeg;base64,)
        if "," in base64_data:
            base64_data = base64_data.split(",")[1]

        # è§£ç¢¼ base64 ç‚º bytes
        image_bytes = base64.b64decode(base64_data)

        # è½‰æ›ç‚º numpy array
        nparr = np.frombuffer(image_bytes, np.uint8)

        # è§£ç¢¼ç‚º BGR åœ–ç‰‡
        bgr_img = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
        return bgr_img
    except Exception as e:
        logger.error(f"è§£ç¢¼åœ–ç‰‡å¤±æ•—: {e}")
        return None


def encode_image_to_base64(rgb_img: np.ndarray) -> str:
    # è½‰æ› RGB åˆ° BGR
    bgr_img = cv2.cvtColor(rgb_img, cv2.COLOR_RGB2BGR)

    # ç·¨ç¢¼ç‚º JPEG
    success_bool, buffer = cv2.imencode(
        ".jpg",
        bgr_img,
        [cv2.IMWRITE_JPEG_QUALITY, 90],
    )
    if not success_bool:
        raise ValueError("åœ–ç‰‡ç·¨ç¢¼å¤±æ•—")

    # è½‰æ›ç‚º base64
    base64_str = base64.b64encode(buffer).decode("utf-8")
    return f"data:image/jpeg;base64,{base64_str}"


def calculate_output_size(
    img_height_int: int,
    img_width_int: int,
    target_width_int: int = OUTPUT_WIDTH_INT,
) -> tuple[int, int]:
    aspect_ratio_num = img_height_int / img_width_int
    target_height_int = int(target_width_int * aspect_ratio_num)
    return (target_width_int, target_height_int)


def process_card_detection(
    bgr_img: np.ndarray,
    frame_count_int: int,
) -> tuple[bool, np.ndarray | None, int]:
    try:
        # åµæ¸¬è­‰ä»¶/å¡ç‰‡
        poly_arr = DOC_ALIGNER(img=bgr_img, do_center_crop=True)
        poly_len_int = len(poly_arr)

        # Debug: è¨˜éŒ„åµæ¸¬çµæœ
        if poly_len_int == 0:
            logger.debug(f"[å¹€ {frame_count_int}] æœªåµæ¸¬åˆ°ä»»ä½•è§’é»")
        else:
            logger.info(f"[å¹€ {frame_count_int}] åµæ¸¬åˆ° {poly_len_int} å€‹è§’é»: {poly_arr}")

        if poly_len_int != 4:
            return False, None, poly_len_int

        logger.info(f"[å¹€ {frame_count_int}] åµæ¸¬åˆ°å¡ç‰‡ï¼æ­£åœ¨é€²è¡Œé€è¦–æ ¡æ­£...")

        # è½‰æ› BGR åˆ° RGB
        rgb_img = cv2.cvtColor(bgr_img, cv2.COLOR_BGR2RGB)

        # è¨ˆç®—è¼¸å‡ºå°ºå¯¸
        img_height_int, img_width_int = rgb_img.shape[:2]
        output_width_int, output_height_int = calculate_output_size(
            img_height_int=img_height_int,
            img_width_int=img_width_int,
            target_width_int=OUTPUT_WIDTH_INT,
        )

        # é€è¦–æ ¡æ­£
        flat_rgb_img = imwarp_quadrangle(
            img=rgb_img,
            polygon=poly_arr,
            dst_size=(output_width_int, output_height_int),
        )

        return True, flat_rgb_img

    except Exception as e:
        logger.error(f"å¡ç‰‡åµæ¸¬/æ ¡æ­£éŒ¯èª¤: {e}")
        return False, None


def save_corrected_image(rgb_img: np.ndarray) -> Path | None:
    try:
        timestamp_str = datetime.now().strftime("%Y%m%d_%H%M%S_%f")
        filename = f"corrected_{timestamp_str}.jpg"
        filepath = IMAGES_DIR / filename

        # è½‰æ› RGB åˆ° BGR ä¸¦å„²å­˜
        bgr_img = cv2.cvtColor(rgb_img, cv2.COLOR_RGB2BGR)
        cv2.imwrite(str(filepath), bgr_img, [cv2.IMWRITE_JPEG_QUALITY, 95])

        logger.info(f"å·²å„²å­˜æ ¡æ­£å¾Œåœ–ç‰‡: {filename}")
        cleanup_old_images()
        return filepath
    except Exception as e:
        logger.error(f"å„²å­˜åœ–ç‰‡å¤±æ•—: {e}")
        return None


# è¨­å®šéœæ…‹æª”æ¡ˆè·¯å¾‘
app.add_static_files("/static", Path(__file__).parent / "static")


@ui.page("/")
def index_page():
    # é é¢ç‹€æ…‹ï¼ˆæ¯å€‹ client ç¨ç«‹ï¼‰
    is_processing = False
    is_detected = False

    ui.add_head_html('<script src="/static/webcam.js"></script>')

    with ui.column().classes("w-full items-center p-4"):
        ui.label("ğŸ“· å¡ç‰‡æ“·å–èˆ‡æ ¡æ­£").classes("text-2xl font-bold mb-4")

        # å½±åƒé è¦½å€åŸŸï¼ˆåµæ¸¬ä¸­é¡¯ç¤ºï¼‰
        video_card = ui.card().classes("w-full max-w-lg")
        with video_card:
            ui.html(
                '<video id="webcam-video" autoplay playsinline muted '
                'style="width: 100%; border-radius: 8px; background: #000;"></video>',
                sanitize=False,
            )

        # çµæœåœ–ç‰‡å€åŸŸï¼ˆåµæ¸¬æˆåŠŸå¾Œé¡¯ç¤ºï¼‰
        result_card = ui.card().classes("w-full max-w-lg hidden")
        with result_card:
            result_image = ui.image().classes("w-full rounded-lg")

        # ç‹€æ…‹é¡¯ç¤º
        status_label = ui.label("ç‹€æ…‹ï¼šç­‰å¾…å•Ÿå‹•æ”åƒé ­...").classes("mt-4 text-gray-600")

        # é‡æ–°æ‹æ”æŒ‰éˆ•ï¼ˆåˆå§‹éš±è—ï¼‰
        retry_button = ui.button(
            "é‡æ–°æ‹æ”",
            on_click=lambda: ui.run_javascript("location.reload()"),
        ).classes("mt-4 hidden").props("color=primary size=lg")

        # å®šç¾©æ¥æ”¶åœ–ç‰‡çš„è™•ç†å‡½æ•¸
        def on_frame_received(base64_data: str) -> None:
            nonlocal is_processing, is_detected

            # å¦‚æœå·²ç¶“åµæ¸¬æˆåŠŸæˆ–æ­£åœ¨è™•ç†ï¼Œè·³éé€™å¹€
            if is_detected or is_processing:
                return

            if not base64_data or not isinstance(base64_data, str):
                return

            is_processing = True

            try:
                # è§£ç¢¼åœ–ç‰‡
                bgr_img = decode_base64_image(base64_data)
                if bgr_img is None:
                    return

                # åµæ¸¬ä¸¦æ ¡æ­£å¡ç‰‡
                success_bool, flat_rgb_img = process_card_detection(bgr_img)

                if success_bool and flat_rgb_img is not None:
                    is_detected = True

                    # å„²å­˜æ ¡æ­£å¾Œçš„åœ–ç‰‡
                    save_corrected_image(flat_rgb_img)

                    # ç·¨ç¢¼çµæœåœ–ç‰‡ç‚º base64
                    result_base64 = encode_image_to_base64(flat_rgb_img)

                    # æ›´æ–°å‰ç«¯ UI
                    status_label.set_text("ç‹€æ…‹ï¼šå¡ç‰‡æ“·å–æˆåŠŸï¼")

                    # åœæ­¢ webcam æ“·å–
                    ui.run_javascript("WebcamCapture.stopCapture();")

                    # éš±è— videoï¼Œé¡¯ç¤ºçµæœ
                    video_card.classes(add="hidden")
                    result_card.classes(remove="hidden")
                    result_image.set_source(result_base64)

                    # é¡¯ç¤ºé‡æ–°æ‹æ”æŒ‰éˆ•
                    retry_button.classes(remove="hidden")

            finally:
                is_processing = False

        # ä½¿ç”¨å…¨åŸŸäº‹ä»¶ç›£è½
        ui.on("webcam_frame", lambda e: on_frame_received(e.args))

        # åˆå§‹åŒ–æ”åƒé ­ä¸¦è‡ªå‹•é–‹å§‹æ“·å–
        async def init_camera():
            try:
                result = await ui.run_javascript(
                    """
                    (async () => {
                        const success = await WebcamCapture.init('webcam-video');
                        if (success) {
                            WebcamCapture.startCapture((frameData) => {
                                emitEvent('webcam_frame', frameData);
                            });
                        }
                        return success;
                    })()
                    """,
                    timeout=10.0,
                )
                if result:
                    status_label.set_text("ç‹€æ…‹ï¼šåµæ¸¬ä¸­ï¼Œè«‹å°‡å¡ç‰‡å°æº–é¡é ­...")
                else:
                    status_label.set_text("ç‹€æ…‹ï¼šç„¡æ³•å­˜å–æ”åƒé ­ï¼Œè«‹ç¢ºèªæ¬Šé™è¨­å®š")
                return result
            except TimeoutError:
                status_label.set_text("ç‹€æ…‹ï¼šç­‰å¾…é€£ç·šä¸­...")
                logger.warning("JavaScript åˆå§‹åŒ–è¶…æ™‚ï¼Œç­‰å¾…å®¢æˆ¶ç«¯é€£æ¥")
                return False

        # é é¢è¼‰å…¥å¾Œè‡ªå‹•åˆå§‹åŒ–æ”åƒé ­
        ui.timer(0.5, init_camera, once=True)


def main():
    port_int = 25331
    logger.info(f"å•Ÿå‹•å¡ç‰‡æ“·å–èˆ‡æ ¡æ­£ï¼Œç«¯å£: {port_int}")

    ui.run(
        host="0.0.0.0",
        port=port_int,
        title="å¡ç‰‡æ“·å–èˆ‡æ ¡æ­£",
        reload=False,
    )


if __name__ in {"__main__", "__mp_main__"}:
    main()

```

```python
import base64
from datetime import datetime
from pathlib import Path

import cv2
import numpy as np
from capybara import imwarp_quadrangle
from docaligner import DocAligner
from loguru import logger
from nicegui import app, ui

# è¨­å®šåœ–ç‰‡å„²å­˜è·¯å¾‘
IMAGES_DIR = Path(__file__).parent / "images"
IMAGES_DIR.mkdir(exist_ok=True)

# æœ€å¤šä¿ç•™çš„åœ–ç‰‡æ•¸é‡
MAX_IMAGES_COUNT = 30

# è¼¸å‡ºå°ºå¯¸è¨­å®šï¼ˆå¯¬åº¦å›ºå®šï¼Œé«˜åº¦æŒ‰æ¯”ä¾‹ï¼‰
OUTPUT_WIDTH_INT = 800

# åˆå§‹åŒ– DocAlignerï¼ˆå†·å•Ÿå‹•æ™‚è¼‰å…¥æ¨¡å‹ï¼Œé¿å…é¦–æ¬¡åµæ¸¬å»¶é²ï¼‰
logger.info("æ­£åœ¨è¼‰å…¥ DocAligner æ¨¡å‹...")
DOC_ALIGNER = DocAligner()
logger.info("DocAligner æ¨¡å‹è¼‰å…¥å®Œæˆï¼")


def cleanup_old_images() -> None:
    image_path_list = sorted(
        IMAGES_DIR.glob("*.jpg"),
        key=lambda p: p.stat().st_mtime,
    )
    while len(image_path_list) > MAX_IMAGES_COUNT:
        oldest_path = image_path_list.pop(0)
        oldest_path.unlink()
        logger.info(f"å·²åˆªé™¤èˆŠåœ–ç‰‡: {oldest_path.name}")


def decode_base64_image(base64_data: str) -> np.ndarray | None:
    try:
        # ç§»é™¤ base64 header (data:image/jpeg;base64,)
        if "," in base64_data:
            base64_data = base64_data.split(",")[1]

        # è§£ç¢¼ base64 ç‚º bytes
        image_bytes = base64.b64decode(base64_data)

        # è½‰æ›ç‚º numpy array
        nparr = np.frombuffer(image_bytes, np.uint8)

        # è§£ç¢¼ç‚º BGR åœ–ç‰‡
        bgr_img = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
        return bgr_img
    except Exception as e:
        logger.error(f"è§£ç¢¼åœ–ç‰‡å¤±æ•—: {e}")
        return None


def encode_image_to_base64(rgb_img: np.ndarray) -> str:
    # è½‰æ› RGB åˆ° BGR
    bgr_img = cv2.cvtColor(rgb_img, cv2.COLOR_RGB2BGR)

    # ç·¨ç¢¼ç‚º JPEG
    success_bool, buffer = cv2.imencode(
        ".jpg",
        bgr_img,
        [cv2.IMWRITE_JPEG_QUALITY, 90],
    )
    if not success_bool:
        raise ValueError("åœ–ç‰‡ç·¨ç¢¼å¤±æ•—")

    # è½‰æ›ç‚º base64
    base64_str = base64.b64encode(buffer).decode("utf-8")
    return f"data:image/jpeg;base64,{base64_str}"


def calculate_output_size(
    img_height_int: int,
    img_width_int: int,
    target_width_int: int = OUTPUT_WIDTH_INT,
) -> tuple[int, int]:
    aspect_ratio_num = img_height_int / img_width_int
    target_height_int = int(target_width_int * aspect_ratio_num)
    return (target_width_int, target_height_int)


def process_card_detection(
    bgr_img: np.ndarray,
    frame_count_int: int,
) -> tuple[bool, np.ndarray | None, int]:
    try:
        # åµæ¸¬è­‰ä»¶/å¡ç‰‡
        poly_arr = DOC_ALIGNER(img=bgr_img, do_center_crop=True)
        poly_len_int = len(poly_arr)

        # Debug: è¨˜éŒ„åµæ¸¬çµæœ
        if poly_len_int == 0:
            logger.debug(f"[å¹€ {frame_count_int}] æœªåµæ¸¬åˆ°ä»»ä½•è§’é»")
        else:
            logger.info(f"[å¹€ {frame_count_int}] åµæ¸¬åˆ° {poly_len_int} å€‹è§’é»: {poly_arr}")

        if poly_len_int != 4:
            return False, None, poly_len_int

        logger.info(f"[å¹€ {frame_count_int}] åµæ¸¬åˆ°å¡ç‰‡ï¼æ­£åœ¨é€²è¡Œé€è¦–æ ¡æ­£...")

        # è½‰æ› BGR åˆ° RGB
        rgb_img = cv2.cvtColor(bgr_img, cv2.COLOR_BGR2RGB)

        # è¨ˆç®—è¼¸å‡ºå°ºå¯¸
        img_height_int, img_width_int = rgb_img.shape[:2]
        output_width_int, output_height_int = calculate_output_size(
            img_height_int=img_height_int,
            img_width_int=img_width_int,
            target_width_int=OUTPUT_WIDTH_INT,
        )

        # é€è¦–æ ¡æ­£
        flat_rgb_img = imwarp_quadrangle(
            img=rgb_img,
            polygon=poly_arr,
            dst_size=(output_width_int, output_height_int),
        )

        return True, flat_rgb_img, poly_len_int

    except Exception as e:
        logger.error(f"å¡ç‰‡åµæ¸¬/æ ¡æ­£éŒ¯èª¤: {e}")
        return False, None, 0


def save_corrected_image(rgb_img: np.ndarray) -> Path | None:
    try:
        timestamp_str = datetime.now().strftime("%Y%m%d_%H%M%S_%f")
        filename = f"corrected_{timestamp_str}.jpg"
        filepath = IMAGES_DIR / filename

        # è½‰æ› RGB åˆ° BGR ä¸¦å„²å­˜
        bgr_img = cv2.cvtColor(rgb_img, cv2.COLOR_RGB2BGR)
        cv2.imwrite(str(filepath), bgr_img, [cv2.IMWRITE_JPEG_QUALITY, 95])

        logger.info(f"å·²å„²å­˜æ ¡æ­£å¾Œåœ–ç‰‡: {filename}")
        cleanup_old_images()
        return filepath
    except Exception as e:
        logger.error(f"å„²å­˜åœ–ç‰‡å¤±æ•—: {e}")
        return None


# è¨­å®šéœæ…‹æª”æ¡ˆè·¯å¾‘
app.add_static_files("/static", Path(__file__).parent / "static")


@ui.page("/")
def index_page():
    # é é¢ç‹€æ…‹ï¼ˆæ¯å€‹ client ç¨ç«‹ï¼‰
    is_processing = False
    is_detected = False

    ui.add_head_html('<script src="/static/webcam.js"></script>')

    with ui.column().classes("w-full items-center p-4"):
        ui.label("ğŸ“· å¡ç‰‡æ“·å–èˆ‡æ ¡æ­£").classes("text-2xl font-bold mb-4")

        # å½±åƒé è¦½å€åŸŸï¼ˆåµæ¸¬ä¸­é¡¯ç¤ºï¼‰
        video_card = ui.card().classes("w-full max-w-lg")
        with video_card:
            ui.html(
                '<video id="webcam-video" autoplay playsinline muted '
                'style="width: 100%; border-radius: 8px; background: #000;"></video>',
                sanitize=False,
            )

        # çµæœåœ–ç‰‡å€åŸŸï¼ˆåµæ¸¬æˆåŠŸå¾Œé¡¯ç¤ºï¼‰
        result_card = ui.card().classes("w-full max-w-lg hidden")
        with result_card:
            result_image = ui.image().classes("w-full rounded-lg")

        # ç‹€æ…‹é¡¯ç¤º
        status_label = ui.label("ç‹€æ…‹ï¼šç­‰å¾…å•Ÿå‹•æ”åƒé ­...").classes("mt-4 text-gray-600")

        # é‡æ–°æ‹æ”æŒ‰éˆ•ï¼ˆåˆå§‹éš±è—ï¼‰
        retry_button = ui.button(
            "é‡æ–°æ‹æ”",
            on_click=lambda: ui.run_javascript("location.reload()"),
        ).classes("mt-4 hidden").props("color=primary size=lg")

        # å®šç¾©æ¥æ”¶åœ–ç‰‡çš„è™•ç†å‡½æ•¸
        def on_frame_received(base64_data: str) -> None:
            nonlocal is_processing, is_detected

            # å¦‚æœå·²ç¶“åµæ¸¬æˆåŠŸæˆ–æ­£åœ¨è™•ç†ï¼Œè·³éé€™å¹€
            if is_detected or is_processing:
                return

            if not base64_data or not isinstance(base64_data, str):
                return

            is_processing = True

            try:
                # è§£ç¢¼åœ–ç‰‡
                bgr_img = decode_base64_image(base64_data)
                if bgr_img is None:
                    return

                # åµæ¸¬ä¸¦æ ¡æ­£å¡ç‰‡
                success_bool, flat_rgb_img = process_card_detection(bgr_img)

                if success_bool and flat_rgb_img is not None:
                    is_detected = True

                    # å„²å­˜æ ¡æ­£å¾Œçš„åœ–ç‰‡
                    save_corrected_image(flat_rgb_img)

                    # ç·¨ç¢¼çµæœåœ–ç‰‡ç‚º base64
                    result_base64 = encode_image_to_base64(flat_rgb_img)

                    # æ›´æ–°å‰ç«¯ UI
                    status_label.set_text("ç‹€æ…‹ï¼šå¡ç‰‡æ“·å–æˆåŠŸï¼")

                    # åœæ­¢ webcam æ“·å–
                    ui.run_javascript("WebcamCapture.stopCapture();")

                    # éš±è— videoï¼Œé¡¯ç¤ºçµæœ
                    video_card.classes(add="hidden")
                    result_card.classes(remove="hidden")
                    result_image.set_source(result_base64)

                    # é¡¯ç¤ºé‡æ–°æ‹æ”æŒ‰éˆ•
                    retry_button.classes(remove="hidden")

            finally:
                is_processing = False

        # ä½¿ç”¨å…¨åŸŸäº‹ä»¶ç›£è½
        ui.on("webcam_frame", lambda e: on_frame_received(e.args))

        # åˆå§‹åŒ–æ”åƒé ­ä¸¦è‡ªå‹•é–‹å§‹æ“·å–
        async def init_camera():
            try:
                result = await ui.run_javascript(
                    """
                    (async () => {
                        const success = await WebcamCapture.init('webcam-video');
                        if (success) {
                            WebcamCapture.startCapture((frameData) => {
                                emitEvent('webcam_frame', frameData);
                            });
                        }
                        return success;
                    })()
                    """,
                    timeout=10.0,
                )
                if result:
                    status_label.set_text("ç‹€æ…‹ï¼šåµæ¸¬ä¸­ï¼Œè«‹å°‡å¡ç‰‡å°æº–é¡é ­...")
                else:
                    status_label.set_text("ç‹€æ…‹ï¼šç„¡æ³•å­˜å–æ”åƒé ­ï¼Œè«‹ç¢ºèªæ¬Šé™è¨­å®š")
                return result
            except TimeoutError:
                status_label.set_text("ç‹€æ…‹ï¼šç­‰å¾…é€£ç·šä¸­...")
                logger.warning("JavaScript åˆå§‹åŒ–è¶…æ™‚ï¼Œç­‰å¾…å®¢æˆ¶ç«¯é€£æ¥")
                return False

        # é é¢è¼‰å…¥å¾Œè‡ªå‹•åˆå§‹åŒ–æ”åƒé ­
        ui.timer(0.5, init_camera, once=True)


def main():
    port_int = 25331
    logger.info(f"å•Ÿå‹•å¡ç‰‡æ“·å–èˆ‡æ ¡æ­£ï¼Œç«¯å£: {port_int}")

    ui.run(
        host="0.0.0.0",
        port=port_int,
        title="å¡ç‰‡æ“·å–èˆ‡æ ¡æ­£",
        reload=False,
    )


if __name__ in {"__main__", "__mp_main__"}:
    main()

```

```python
import base64
from datetime import datetime
from pathlib import Path

import cv2
import numpy as np
from capybara import imwarp_quadrangle
from docaligner import DocAligner
from loguru import logger
from nicegui import app, ui

# è¨­å®šåœ–ç‰‡å„²å­˜è·¯å¾‘
IMAGES_DIR = Path(__file__).parent / "images"
IMAGES_DIR.mkdir(exist_ok=True)

# æœ€å¤šä¿ç•™çš„åœ–ç‰‡æ•¸é‡
MAX_IMAGES_COUNT = 30

# è¼¸å‡ºå°ºå¯¸è¨­å®šï¼ˆå¯¬åº¦å›ºå®šï¼Œé«˜åº¦æŒ‰æ¯”ä¾‹ï¼‰
OUTPUT_WIDTH_INT = 800

# åˆå§‹åŒ– DocAlignerï¼ˆå†·å•Ÿå‹•æ™‚è¼‰å…¥æ¨¡å‹ï¼Œé¿å…é¦–æ¬¡åµæ¸¬å»¶é²ï¼‰
logger.info("æ­£åœ¨è¼‰å…¥ DocAligner æ¨¡å‹...")
DOC_ALIGNER = DocAligner()
logger.info("DocAligner æ¨¡å‹è¼‰å…¥å®Œæˆï¼")


def cleanup_old_images() -> None:
    image_path_list = sorted(
        IMAGES_DIR.glob("*.jpg"),
        key=lambda p: p.stat().st_mtime,
    )
    while len(image_path_list) > MAX_IMAGES_COUNT:
        oldest_path = image_path_list.pop(0)
        oldest_path.unlink()
        logger.info(f"å·²åˆªé™¤èˆŠåœ–ç‰‡: {oldest_path.name}")


def decode_base64_image(base64_data: str) -> np.ndarray | None:
    try:
        # ç§»é™¤ base64 header (data:image/jpeg;base64,)
        if "," in base64_data:
            base64_data = base64_data.split(",")[1]

        # è§£ç¢¼ base64 ç‚º bytes
        image_bytes = base64.b64decode(base64_data)

        # è½‰æ›ç‚º numpy array
        nparr = np.frombuffer(image_bytes, np.uint8)

        # è§£ç¢¼ç‚º BGR åœ–ç‰‡
        bgr_img = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
        return bgr_img
    except Exception as e:
        logger.error(f"è§£ç¢¼åœ–ç‰‡å¤±æ•—: {e}")
        return None


def encode_image_to_base64(rgb_img: np.ndarray) -> str:
    # è½‰æ› RGB åˆ° BGR
    bgr_img = cv2.cvtColor(rgb_img, cv2.COLOR_RGB2BGR)

    # ç·¨ç¢¼ç‚º JPEG
    success_bool, buffer = cv2.imencode(
        ".jpg",
        bgr_img,
        [cv2.IMWRITE_JPEG_QUALITY, 90],
    )
    if not success_bool:
        raise ValueError("åœ–ç‰‡ç·¨ç¢¼å¤±æ•—")

    # è½‰æ›ç‚º base64
    base64_str = base64.b64encode(buffer).decode("utf-8")
    return f"data:image/jpeg;base64,{base64_str}"


def calculate_output_size(
    img_height_int: int,
    img_width_int: int,
    target_width_int: int = OUTPUT_WIDTH_INT,
) -> tuple[int, int]:
    aspect_ratio_num = img_height_int / img_width_int
    target_height_int = int(target_width_int * aspect_ratio_num)
    return (target_width_int, target_height_int)


def process_card_detection(
    bgr_img: np.ndarray,
    frame_count_int: int,
) -> tuple[bool, np.ndarray | None, int]:
    try:
        # åµæ¸¬è­‰ä»¶/å¡ç‰‡
        poly_arr = DOC_ALIGNER(img=bgr_img, do_center_crop=True)
        poly_len_int = len(poly_arr)

        # Debug: è¨˜éŒ„åµæ¸¬çµæœ
        if poly_len_int == 0:
            logger.debug(f"[å¹€ {frame_count_int}] æœªåµæ¸¬åˆ°ä»»ä½•è§’é»")
        else:
            logger.info(f"[å¹€ {frame_count_int}] åµæ¸¬åˆ° {poly_len_int} å€‹è§’é»: {poly_arr}")

        if poly_len_int != 4:
            return False, None, poly_len_int

        logger.info(f"[å¹€ {frame_count_int}] åµæ¸¬åˆ°å¡ç‰‡ï¼æ­£åœ¨é€²è¡Œé€è¦–æ ¡æ­£...")

        # è½‰æ› BGR åˆ° RGB
        rgb_img = cv2.cvtColor(bgr_img, cv2.COLOR_BGR2RGB)

        # è¨ˆç®—è¼¸å‡ºå°ºå¯¸
        img_height_int, img_width_int = rgb_img.shape[:2]
        output_width_int, output_height_int = calculate_output_size(
            img_height_int=img_height_int,
            img_width_int=img_width_int,
            target_width_int=OUTPUT_WIDTH_INT,
        )

        # é€è¦–æ ¡æ­£
        flat_rgb_img = imwarp_quadrangle(
            img=rgb_img,
            polygon=poly_arr,
            dst_size=(output_width_int, output_height_int),
        )

        return True, flat_rgb_img, poly_len_int

    except Exception as e:
        logger.error(f"å¡ç‰‡åµæ¸¬/æ ¡æ­£éŒ¯èª¤: {e}")
        return False, None, 0


def save_corrected_image(rgb_img: np.ndarray) -> Path | None:
    try:
        timestamp_str = datetime.now().strftime("%Y%m%d_%H%M%S_%f")
        filename = f"corrected_{timestamp_str}.jpg"
        filepath = IMAGES_DIR / filename

        # è½‰æ› RGB åˆ° BGR ä¸¦å„²å­˜
        bgr_img = cv2.cvtColor(rgb_img, cv2.COLOR_RGB2BGR)
        cv2.imwrite(str(filepath), bgr_img, [cv2.IMWRITE_JPEG_QUALITY, 95])

        logger.info(f"å·²å„²å­˜æ ¡æ­£å¾Œåœ–ç‰‡: {filename}")
        cleanup_old_images()
        return filepath
    except Exception as e:
        logger.error(f"å„²å­˜åœ–ç‰‡å¤±æ•—: {e}")
        return None


# è¨­å®šéœæ…‹æª”æ¡ˆè·¯å¾‘
app.add_static_files("/static", Path(__file__).parent / "static")


@ui.page("/")
def index_page():
    # é é¢ç‹€æ…‹ï¼ˆæ¯å€‹ client ç¨ç«‹ï¼‰
    is_processing = False
    is_detected = False
    frame_count_int = 0

    ui.add_head_html('<script src="/static/webcam.js"></script>')

    with ui.column().classes("w-full items-center p-4"):
        ui.label("ğŸ“· å¡ç‰‡æ“·å–èˆ‡æ ¡æ­£").classes("text-2xl font-bold mb-4")

        # å½±åƒé è¦½å€åŸŸï¼ˆåµæ¸¬ä¸­é¡¯ç¤ºï¼‰
        video_card = ui.card().classes("w-full max-w-lg")
        with video_card:
            ui.html(
                '<video id="webcam-video" autoplay playsinline muted '
                'style="width: 100%; border-radius: 8px; background: #000;"></video>',
                sanitize=False,
            )

        # çµæœåœ–ç‰‡å€åŸŸï¼ˆåµæ¸¬æˆåŠŸå¾Œé¡¯ç¤ºï¼‰
        result_card = ui.card().classes("w-full max-w-lg hidden")
        with result_card:
            result_image = ui.image().classes("w-full rounded-lg")

        # ç‹€æ…‹é¡¯ç¤º
        status_label = ui.label("ç‹€æ…‹ï¼šç­‰å¾…å•Ÿå‹•æ”åƒé ­...").classes("mt-4 text-gray-600")

        # Debug è³‡è¨Šé¡¯ç¤º
        debug_label = ui.label("").classes("mt-2 text-sm text-blue-500 font-mono")

        # é‡æ–°æ‹æ”æŒ‰éˆ•ï¼ˆåˆå§‹éš±è—ï¼‰
        retry_button = ui.button(
            "é‡æ–°æ‹æ”",
            on_click=lambda: ui.run_javascript("location.reload()"),
        ).classes("mt-4 hidden").props("color=primary size=lg")

        # å®šç¾©æ¥æ”¶åœ–ç‰‡çš„è™•ç†å‡½æ•¸
        def on_frame_received(base64_data: str) -> None:
            nonlocal is_processing, is_detected, frame_count_int

            # å¦‚æœå·²ç¶“åµæ¸¬æˆåŠŸæˆ–æ­£åœ¨è™•ç†ï¼Œè·³éé€™å¹€
            if is_detected or is_processing:
                return

            if not base64_data or not isinstance(base64_data, str):
                logger.warning("æ”¶åˆ°ç„¡æ•ˆçš„åœ–ç‰‡æ•¸æ“š")
                return

            is_processing = True
            frame_count_int += 1

            try:
                # è§£ç¢¼åœ–ç‰‡
                bgr_img = decode_base64_image(base64_data)
                if bgr_img is None:
                    logger.error(f"[å¹€ {frame_count_int}] åœ–ç‰‡è§£ç¢¼å¤±æ•—")
                    debug_label.set_text(f"[å¹€ {frame_count_int}] åœ–ç‰‡è§£ç¢¼å¤±æ•—")
                    return

                # Debug: è¨˜éŒ„åœ–ç‰‡å°ºå¯¸
                img_height_int, img_width_int = bgr_img.shape[:2]
                logger.info(
                    f"[å¹€ {frame_count_int}] æ”¶åˆ°åœ–ç‰‡: {img_width_int}x{img_height_int}"
                )

                # åµæ¸¬ä¸¦æ ¡æ­£å¡ç‰‡
                success_bool, flat_rgb_img, poly_len_int = process_card_detection(
                    bgr_img=bgr_img,
                    frame_count_int=frame_count_int,
                )

                # æ›´æ–° debug è³‡è¨Š
                debug_label.set_text(
                    f"[å¹€ {frame_count_int}] å°ºå¯¸: {img_width_int}x{img_height_int}, "
                    f"åµæ¸¬è§’é»æ•¸: {poly_len_int}"
                )

                if success_bool and flat_rgb_img is not None:
                    is_detected = True
                    logger.info(f"[å¹€ {frame_count_int}] å¡ç‰‡æ“·å–æˆåŠŸï¼")

                    # å„²å­˜æ ¡æ­£å¾Œçš„åœ–ç‰‡
                    save_corrected_image(flat_rgb_img)

                    # ç·¨ç¢¼çµæœåœ–ç‰‡ç‚º base64
                    result_base64 = encode_image_to_base64(flat_rgb_img)

                    # æ›´æ–°å‰ç«¯ UI
                    status_label.set_text("ç‹€æ…‹ï¼šå¡ç‰‡æ“·å–æˆåŠŸï¼")
                    debug_label.set_text(
                        f"ç¸½å…±è™•ç† {frame_count_int} å¹€å¾ŒæˆåŠŸåµæ¸¬"
                    )

                    # åœæ­¢ webcam æ“·å–
                    ui.run_javascript("WebcamCapture.stopCapture();")

                    # éš±è— videoï¼Œé¡¯ç¤ºçµæœ
                    video_card.classes(add="hidden")
                    result_card.classes(remove="hidden")
                    result_image.set_source(result_base64)

                    # é¡¯ç¤ºé‡æ–°æ‹æ”æŒ‰éˆ•
                    retry_button.classes(remove="hidden")

            except Exception as e:
                logger.error(f"[å¹€ {frame_count_int}] è™•ç†éŒ¯èª¤: {e}")
                debug_label.set_text(f"[å¹€ {frame_count_int}] éŒ¯èª¤: {e}")

            finally:
                is_processing = False

        # ä½¿ç”¨å…¨åŸŸäº‹ä»¶ç›£è½
        ui.on("webcam_frame", lambda e: on_frame_received(e.args))

        # åˆå§‹åŒ–æ”åƒé ­ä¸¦è‡ªå‹•é–‹å§‹æ“·å–
        async def init_camera():
            try:
                result = await ui.run_javascript(
                    """
                    (async () => {
                        const success = await WebcamCapture.init('webcam-video');
                        if (success) {
                            WebcamCapture.startCapture((frameData) => {
                                emitEvent('webcam_frame', frameData);
                            });
                        }
                        return success;
                    })()
                    """,
                    timeout=10.0,
                )
                if result:
                    status_label.set_text("ç‹€æ…‹ï¼šåµæ¸¬ä¸­ï¼Œè«‹å°‡å¡ç‰‡å°æº–é¡é ­...")
                else:
                    status_label.set_text("ç‹€æ…‹ï¼šç„¡æ³•å­˜å–æ”åƒé ­ï¼Œè«‹ç¢ºèªæ¬Šé™è¨­å®š")
                return result
            except TimeoutError:
                status_label.set_text("ç‹€æ…‹ï¼šç­‰å¾…é€£ç·šä¸­...")
                logger.warning("JavaScript åˆå§‹åŒ–è¶…æ™‚ï¼Œç­‰å¾…å®¢æˆ¶ç«¯é€£æ¥")
                return False

        # é é¢è¼‰å…¥å¾Œè‡ªå‹•åˆå§‹åŒ–æ”åƒé ­
        ui.timer(0.5, init_camera, once=True)


def main():
    port_int = 25331
    logger.info(f"å•Ÿå‹•å¡ç‰‡æ“·å–èˆ‡æ ¡æ­£ï¼Œç«¯å£: {port_int}")

    ui.run(
        host="0.0.0.0",
        port=port_int,
        title="å¡ç‰‡æ“·å–èˆ‡æ ¡æ­£",
        reload=False,
    )


if __name__ in {"__main__", "__mp_main__"}:
    main()

```

å·²å¢åŠ  debug è³‡è¨Šï¼ç¾åœ¨æœƒé¡¯ç¤ºï¼š

**å¾Œç«¯æ—¥èªŒ (çµ‚ç«¯æ©Ÿ)**:
- æ¯æ”¶åˆ°ä¸€å¹€ï¼šè¨˜éŒ„åœ–ç‰‡å°ºå¯¸ `[å¹€ X] æ”¶åˆ°åœ–ç‰‡: WxH`
- åµæ¸¬çµæœï¼šè¨˜éŒ„åµæ¸¬åˆ°çš„è§’é»æ•¸é‡å’Œåº§æ¨™ `[å¹€ X] åµæ¸¬åˆ° N å€‹è§’é»`

**å‰ç«¯ UI**:
- æ–°å¢è—è‰² debug æ–‡å­—ï¼Œå³æ™‚é¡¯ç¤ºï¼š
  - å¹€ç·¨è™Ÿ
  - åœ–ç‰‡å°ºå¯¸
  - åµæ¸¬è§’é»æ•¸ï¼ˆéœ€è¦ 4 å€‹è§’é»æ‰ç®—æˆåŠŸï¼‰

è«‹é‡æ–°é‹è¡Œæ‡‰ç”¨ï¼š

```powershell
uv run main.py
```

ç„¶å¾Œè§€å¯Ÿï¼š
1. **çµ‚ç«¯æ©Ÿ** - æ‡‰è©²æœƒçœ‹åˆ°æ¯ç§’ 2 æ¬¡çš„åµæ¸¬æ—¥èªŒ
2. **ç¶²é ** - æ‡‰è©²æœƒçœ‹åˆ°å³æ™‚æ›´æ–°çš„ debug è³‡è¨Š

å¦‚æœå®Œå…¨æ²’æœ‰æ—¥èªŒè¼¸å‡ºï¼Œå¯èƒ½æ˜¯å‰ç«¯æ²’æœ‰æ­£ç¢ºç™¼é€åœ–ç‰‡ã€‚å¦‚æœæœ‰è¼¸å‡ºä½†è§’é»æ•¸ä¸€ç›´æ˜¯ 0ï¼Œå‰‡å¯èƒ½æ˜¯ï¼š
- å¡ç‰‡ä¸åœ¨ç•«é¢ä¸­
- å…‰ç·šä¸è¶³
- èƒŒæ™¯å¤ªè¤‡é›œ

```powershell
uv run main.py
```

